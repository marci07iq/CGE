#include "Ply.h"

#include "TinyPly.cpp"

void write_ply(ostream& _file, vector<ply_vertex_pos>& _pos, vector<colorargb>& _col, vector<ply_face_coords>& _tris, bool _binary) {
  /*geometry cube = make_cube_geometry();

  std::filebuf fb_binary;
  fb_binary.open(filename + "-binary.ply", std::ios::out | std::ios::binary);
  std::ostream outstream_binary(&fb_binary);
  if (outstream_binary.fail()) throw std::runtime_error("failed to open " + filename);

  std::filebuf fb_ascii;
  fb_ascii.open(filename + "-ascii.ply", std::ios::out);
  std::ostream outstream_ascii(&fb_ascii);
  if (outstream_ascii.fail()) throw std::runtime_error("failed to open " + filename);
  */
  using namespace tinyply;

  PlyFile cube_file;

  cube_file.add_properties_to_element("vertex", { "x", "y", "z" },
    Type::FLOAT32, _pos.size(), reinterpret_cast<uint8_t*>(_pos.data()), Type::INVALID, 0);

  cube_file.add_properties_to_element("vertex", {  "blue", "green", "red", "alpha" },
    Type::UINT8, _col.size(), reinterpret_cast<uint8_t*>(_col.data()), Type::INVALID, 0);

  cube_file.add_properties_to_element("face", { "vertex_indices" },
    Type::UINT32, _tris.size(), reinterpret_cast<uint8_t*>(_tris.data()), Type::UINT8, 3);

  cube_file.get_comments().push_back("generated by tinyply 2.2");

  // Write a binary file
  cube_file.write(_file, _binary);
}

void read_ply(istream& _file, vector<ply_vertex_pos>& _pos, vector<colorargb>& _col, vector<ply_face_coords>& _tris) {
  using namespace tinyply;

  try {
    PlyFile file;
    file.parse_header(_file);

    // Tinyply treats parsed data as untyped byte buffers. See below for examples.
    std::shared_ptr<PlyData> positions, colors, alphas, faces;

    // The header information can be used to programmatically extract properties on elements
    // known to exist in the header prior to reading the data. For brevity of this sample, properties 
    // like vertex position are hard-coded: 
    try { positions = file.request_properties_from_element("vertex", { "x", "y", "z" }); } catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }

    try { colors = file.request_properties_from_element("vertex", { "red", "green", "blue" }); } catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }
    try { alphas = file.request_properties_from_element("vertex", { "alpha" }); } catch (const std::exception & e) {};

    // Providing a list size hint (the last argument) is a 2x performance improvement. If you have 
    // arbitrary ply files, it is best to leave this 0. 
    try { faces = file.request_properties_from_element("face", { "vertex_indices" }, 3); } catch (const std::exception & e) { std::cerr << "tinyply exception: " << e.what() << std::endl; }
    
    file.read(_file);

    if (positions) {
      _pos.resize(positions->count);
      if (positions->t == tinyply::Type::FLOAT32) {
        float* data = reinterpret_cast<float*>(positions->buffer.get());
        for (size_t i = 0; i < positions->count; i++) {
          _pos[i] = {
          float(data[3 * i + 0]),
            float(data[3 * i + 1]),
            float(data[3 * i + 2]) };
        }
      } else if (positions->t == tinyply::Type::FLOAT64) {
        double* data = reinterpret_cast<double*>(positions->buffer.get());
        for (size_t i = 0; i < positions->count; i++) {
          _pos[i] = {
            float(data[3 * i + 0]),
            float(data[3 * i + 1]),
            float(data[3 * i + 2]) };
        }
      } else {
        cerr << "This position type is not supported" << endl;
      }
    } else {
      cerr << "No position information!" << endl;
    }


    if(colors && colors->count == positions->count){
      _col.resize(colors->count, 0xff000000);
      if (alphas && colors->count == alphas->count) {
        if (alphas->t == tinyply::Type::UINT8) {
          uint8_t* data = reinterpret_cast<uint8_t*>(alphas->buffer.get());
          for (size_t i = 0; i < alphas->count; i++) {
            _col[i] = int(data[i]) << 24;
          }
        } else if (colors->t == tinyply::Type::FLOAT32) {
          float* data = reinterpret_cast<float*>(alphas->buffer.get());
          for (size_t i = 0; i < alphas->count / 3; i++) {
            _col[i] = int(data[i] * 255) << 24;
          }
        } else {
          cerr << "This alpha type is not supported" << endl;
        }
      }

      if (colors->t == tinyply::Type::UINT8) {
        uint8_t* data = reinterpret_cast<uint8_t*>(colors->buffer.get());
        for (size_t i = 0; i < colors->count; i++) {
          _col[i] |= (int(data[3 * i]) << 16) | (int(data[3 * i + 1]) << 8) | int(data[3 * i + 2]);
        }
      } else if (colors->t == tinyply::Type::FLOAT32) {
        float* data = reinterpret_cast<float*>(colors->buffer.get());
        for (size_t i = 0; i < colors->count / 3; i++) {
          _col[i] |= (int(data[3 * i] * 255) << 16) | (int(data[3 * i + 1] * 255) << 8) | int(data[3 * i + 2] * 255);
        }
      } else {
        cerr << "This color type is not supported" << endl;
      }
    }

    if (faces->count) {
      _tris.resize(faces->count);
      if (faces->t == tinyply::Type::UINT8) {
        uint8_t* data = reinterpret_cast<uint8_t*>(faces->buffer.get());
        for (size_t i = 0; i < faces->count; i++) {
          _tris[i] = {
            uint32_t(data[3 * i + 0]),
            uint32_t(data[3 * i + 1]),
            uint32_t(data[3 * i + 2]) };
        }
      } else if (faces->t == tinyply::Type::UINT16) {
        uint16_t* data = reinterpret_cast<uint16_t*>(faces->buffer.get());
        for (size_t i = 0; i < faces->count; i++) {
          _tris[i] = {
            uint32_t(data[3 * i + 0]),
            uint32_t(data[3 * i + 1]),
            uint32_t(data[3 * i + 2]) };
        }
      } else if (faces->t == tinyply::Type::UINT32) {
        uint32_t* data = reinterpret_cast<uint32_t*>(faces->buffer.get());
        for (size_t i = 0; i < faces->count; i++) {
          _tris[i] = {
            uint32_t(data[3 * i + 0]),
            uint32_t(data[3 * i + 1]),
            uint32_t(data[3 * i + 2]) };
        }
      } else  if (faces->t == tinyply::Type::INT8) {
        int8_t* data = reinterpret_cast<int8_t*>(faces->buffer.get());
        for (size_t i = 0; i < faces->count; i++) {
          _tris[i] = {
            uint32_t(data[3 * i + 0]),
            uint32_t(data[3 * i + 1]),
            uint32_t(data[3 * i + 2]) };
        }
      } else if (faces->t == tinyply::Type::INT16) {
        int16_t* data = reinterpret_cast<int16_t*>(faces->buffer.get());
        for (size_t i = 0; i < faces->count; i++) {
          _tris[i] = {
            uint32_t(data[3 * i + 0]),
            uint32_t(data[3 * i + 1]),
            uint32_t(data[3 * i + 2]) };
        }
      } else if (faces->t == tinyply::Type::INT32) {
        int32_t* data = reinterpret_cast<int32_t*>(faces->buffer.get());
        for (size_t i = 0; i < faces->count; i++) {
          _tris[i] = {
            uint32_t(data[3 * i + 0]),
            uint32_t(data[3 * i + 1]),
            uint32_t(data[3 * i + 2]) };
        }
      } else {
        cerr << "This face id type is not supported" << endl;
      }
    } else {
      cerr << "No faces. What is this file?" << endl;
    }
  } catch (const std::exception & e) {
    std::cerr << "Caught tinyply exception: " << e.what() << std::endl;
  }
}